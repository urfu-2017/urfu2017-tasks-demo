# Задача к лекции «Асинхронность» - «Котофайлы»

### Общие требования

Мы очень хотим, чтобы код вы написали сами, а __не пользовались внешними библиотеками__.

Прежде чем отправлять решение, проверьте его на соответствие [общим требованиям](https://github.com/urfu-2015/guides/blob/master/js-codestyle.md).

Когда вы создадите или обновите пулл-реквест, он автоматически будет проверен
на соответствие кодстайлу и базовую работоспособность. Результаты вы увидите внизу:

Если всё хорошо:  
<img width="308" alt="2015-10-08_1845" src="https://cloud.githubusercontent.com/assets/4534405/10368030/ccc43228-6dec-11e5-925e-47793862d13e.png">

Если всё плохо:  
<img width="218" alt="2015-10-08_1841" src="https://cloud.githubusercontent.com/assets/4534405/10367916/60487fc8-6dec-11e5-9e1d-2a1b15da2220.png">

Проверить можно и вручную:

```js
npm install
npm test

// В результате выведутся ошибки, если они есть
```

### Задача

Интернет-магазин моей бабуленьки набирает популярность, количество котиков
непрерывно растёт и пора начать где-то хранить данные о них. Бабуленька любит
всё старомодное, поэтому хранить мы будем в старых-добрых файлах в папке `/cats`.

К счастью, в Node.JS много методов для работы с файлами:

- [fs.readFile](https://nodejs.org/api/fs.html#fs_fs_readfile_file_options_callback)
- [fs.readdir](https://nodejs.org/api/fs.html#fs_fs_readdir_path_callback)
- [fs.stat](https://nodejs.org/api/fs.html#fs_fs_stat_path_callback)

Но они асинхронные, а значит нужна библиотека для удобной работы с ними `lib/flow.js`

`flow.serial([func1, func2], callback)`
Функция `serial` запускает функции в массиве последовательно. Результат функции передается в следующую. Помимо результата предыдущей функции, она получает колбэк. Колбэк принимает первым параметром ошибку, а вторым – данные для следующей функции. Если любая из функций передает в колбэк ошибку, то следующая не выполняется, а вызывается основной колбэк `callback`.

`flow.parallel([func1, func2], callback)`
Функция `parallel` запускает функции в массиве параллельно. Результат собираются в массив, который передается в основной колбэк при завершении всех функций. Функции принимают колбэк. Колбэк принимает первым параметром ошибку, а вторым – данные для конечного массива.

`flow.map(['value1', 'value2'], func, callback)`
Функция `map` запускает функцию с каждым значением параллельно. Функция принимает значение из массива и колбэк. Результат собираются в массив, который передается в основной колбэк при завершении всех запусков.

Пример работы с библиотекой с подробными комментариями можно традиционно найти в `index.js`.

### Необязательное задание (+27 к концентрации)

`flow.makeAsync(func)`
Функция превращает синхронную функцию в асинхронную.

```js
flow.serial([
    function (next) {
        fs.readFile('./cats/barsik.json', next);
    },
    flow.makeAsync(JSON.parse)
], function (err, parsedJson) {
    console.log(parsedJson);
});
```

`flow.parallel([func1, func2, func3, func4], limit, callback)`
Функция аналогична `parallel`, но в один момент времени могут выполняться не больше `limit` функций,
если какая-то функция завершилась можно запускать следуюущую. Важно следить, чтобы кол-во одновременно
запущенных функций __было равно__ `limit` (если функций осталось мало, то меньше `limit`).

![](https://cloud.githubusercontent.com/assets/4534405/11371012/0275bd18-92e8-11e5-8b65-08bc10d6d5bf.jpg)
