# Задача к лекции «Тесты» – «Тесты»

В качестве задания к лекции про тестирование, после продолжительного мозгового штурма,
ме решили предложить вам [написать тесты](https://yandex.ru/search/?lr=213&msid=20946.30320.1457006003.08429&text=%D0%BA%D0%B0%D0%BF%D0%B8%D1%82%D0%B0%D0%BD%20%D0%BE%D1%87%D0%B5%D0%B2%D0%B8%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%8C
) на одну из задач из первого семестра.

Для этого необходимо:

1. Выбрать любимую задачу из первого семестра
2. Написать тесты

Чтобы облегчить вам задание, мы решили выполнить первый пункт своими силами и выбрать любимую задачу
за вас. Нам кажется, что больше всего
вам понравилась [девятая задача](https://github.com/urfu-2015/javascript-tasks-9) первого семестра, где вы реализовали прекрасную библиотеку «Flow». Которая предлагала следующий интерфейс:

__flow.serial([func1, func2], callback)__  
Метод `serial` запускает функции `[func1, func2]` в массиве последовательно. Результат функции передается в следующую. Помимо результата предыдущей функции, она получает колбэк. Колбэк принимает первым параметром ошибку, а вторым – данные для следующей функции. Если любая из функций передает в колбэк ошибку, то следующая не выполняется, а вызывается основной колбэк `callback`.

```js
flow
    .serial([
        function(next) {
            next(err, 'result1');
        },

        function(data, next) { // data === 'result1'
            next(err, 'result2');
        }
    ], function (err, result) { // result === 'result2'

    });
```

__flow.parallel([func1, func2], callback)__  
Метод `parallel` запускает функции `[func1, func2]` в массиве параллельно. Результат собирается в массив, который передается в основной `callback` при завершении всех функций. Функции `func1`, `func2` тоже принимают колбэк. Колбэк принимает первым параметром ошибку, а вторым – данные для конечного массива.

```js
flow
    .parallel([
        function(next) {
            next(err, 'result1');
        },

        function(next) {
            next(err, 'result2');
        }
    ], function (err, results) { // results === ['result1', 'result2']

    });
```

__flow.map(['value1', 'value2'], func, callback)__  
Метод `map` запускает функцию `func` с каждым значением `['value1', 'value2']` параллельно. Результат собираются в массив, который передаётся в основной `callback` при завершении всех запусков.

# Дополнительное задание

[Покрыть тестами дополнительное задание](https://yandex.ru/search/?lr=213&msid=20946.30320.1457006003.08429&text=%D0%BA%D0%B0%D0%BF%D0%B8%D1%82%D0%B0%D0%BD%20%D0%BE%D1%87%D0%B5%D0%B2%D0%B8%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%8C):

__flow.makeAsync(func)__   
Метод превращает синхронную функцию `func` в асинхронную.

__flow.parallel([func1, func2, func3, func4], limit, callback)__  
Метод аналогичен `parallel`, но в один момент времени могут выполняться не больше `limit` функций, если какая-то функция завершилась можно запускать следующую. Важно следить, чтобы количество одновременно запущенных функций было равно `limit` (если функций осталось мало, то меньше `limit`).

<img src="https://cloud.githubusercontent.com/assets/4534405/13493898/afbcd3f8-e162-11e5-8674-56377a79cf1a.png" alt="Всем тесты, котаны!" title="Всем тесты, котаны!">
